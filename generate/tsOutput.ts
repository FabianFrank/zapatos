/*
Zapatos: https://jawj.github.io/zapatos/
Copyright (C) 2020 George MacKerron
Released under the MIT licence: see LICENCE file
*/

import * as pg from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import { enumDataForSchema, enumTypesForEnumData } from './enums';
import { tablesInSchema, definitionForTableInSchema, crossTableTypesForTables } from './tables';
import { moduleRoot } from './config';
import { customFolderName } from './write';
import type { CompleteConfig } from './config';


export interface CustomTypes {
  [name: string]: string;  // any, or TS type for domain's base type
}

const header = () => {
  const
    pkgPath = path.join(moduleRoot(), 'package.json'),
    pkg = JSON.parse(fs.readFileSync(pkgPath, { encoding: 'utf8' }));

  return `/*
** DON'T EDIT THIS FILE **
It's been generated by Zapatos (v${pkg.version}), and is liable to be overwritten

Zapatos: https://jawj.github.io/zapatos/
Copyright (C) 2020 George MacKerron
Released under the MIT licence: see LICENCE file
*/

import type {
  JSONValue,
  JSONArray,
  DateString,
  SQLFragment,
  SQL,
  GenericSQLExpression,
  ColumnNames,
  ColumnValues,
  ParentColumn,
  DefaultType,
} from './src/core';

`;
};

const customTypeHeader = `/*
** Please do edit this file as needed **
It's a placeholder for a custom type definition
*/
`;

const importsForCustomTypes = (customTypes: CustomTypes) =>
  Object.keys(customTypes)
    .sort()
    .map(customType => `import type ${customType} from './${customFolderName}/${customType}';`)
    .join('\n');

const sourceFilesForCustomTypes = (customTypes: CustomTypes) =>
  Object.fromEntries(Object.entries(customTypes)
    .map(([name, baseType]) => [
      `${name}.ts`,
      `${customTypeHeader}${baseType === 'JSONValue' ? "\nimport type { JSONValue } from '../src/core';\n" : ""}
type ${name} = ${baseType};  // replace with your custom type or interface as desired

export default ${name};
`,
    ]));


export const tsForConfig = async (config: CompleteConfig) => {
  const
    { schemas, db } = config,
    pool = new pg.Pool(db),
    customTypes = {},
    schemaData = (await Promise.all(
      Object.keys(schemas).map(async schema => {
        const
          rules = schemas[schema],
          tables = rules.exclude === '*' ? [] :  // exclude takes precedence
            (rules.include === '*' ? await tablesInSchema(schema, pool) : rules.include)
              .filter(table => rules.exclude.indexOf(table) < 0),
          enums = await enumDataForSchema(schema, pool),
          tableDefs = await Promise.all(tables.map(async table =>
            definitionForTableInSchema(table, schema, enums, customTypes, pool))),
          schemaDef = `\n/* === schema: ${schema} === */\n` +
            `\n/* --- enums --- */\n` +
            enumTypesForEnumData(enums) +
            `\n\n/* --- tables --- */\n` +
            tableDefs.sort().join('\n');

        return { schemaDef, tables };
      }))
    ),
    schemaDefs = schemaData.map(r => r.schemaDef).sort(),
    schemaTables = schemaData.map(r => r.tables),
    allTables = ([] as string[]).concat(...schemaTables).sort(),
    ts = header() +
      importsForCustomTypes(customTypes) + '\n\n' +
      schemaDefs.join('\n\n') +
      `\n\n/* === cross-table types === */\n` +
      crossTableTypesForTables(allTables),
    customTypeSourceFiles = sourceFilesForCustomTypes(customTypes);

  await pool.end();
  return { ts, customTypeSourceFiles };
};